import ChatAnalytics from '../../models/ChatAnalytics.js';

/**
 * Updates chat analytics for a given business
 */
export const trackChatEvent = async (businessId, eventType, data = {}) => {
    try {
        console.log(`[AnalyticsService] Tracking event: ${eventType} for business: ${businessId}, Data: ${JSON.stringify(data)}`);
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        let todayOps = {}; 
        let allTimeOps = {}; 

        // --- Perform Lead Increment Separately --- 
        if (eventType === 'NEW_LEAD') {
            console.log('[AnalyticsService] Incrementing totalLeads separately...');
            try {
                console.log(`[AnalyticsService] Attempting today's lead increment. Filter: { businessId: ${businessId}, date: ${today} }`);
                const todayUpdateResult = await ChatAnalytics.updateOne({ businessId, date: today }, { $inc: { totalLeads: 1 } }, { upsert: true });
                console.log('[AnalyticsService] Today lead increment result:', JSON.stringify(todayUpdateResult));

                console.log(`[AnalyticsService] Attempting all-time lead increment. Filter: { businessId: ${businessId}, date: null }`);
                const allTimeUpdateResult = await ChatAnalytics.updateOne({ businessId, date: null }, { $inc: { totalLeads: 1 } }, { upsert: true });
                console.log('[AnalyticsService] All-time lead increment result:', JSON.stringify(allTimeUpdateResult));

                console.log('[AnalyticsService] Separate totalLeads increment successful.');
            } catch (leadIncError) {
                 console.error('[AnalyticsService] Error during separate totalLeads increment:', leadIncError);
                 // Decide if we should continue or throw
            }
        }
        // --- End Separate Lead Increment ---

        // Now build the remaining ops for other event types or service counts
        switch (eventType) {
            case 'NEW_CONVERSATION':
                todayOps = { $inc: { totalConversations: 1 } };
                allTimeOps = { $inc: { totalConversations: 1 } };
                break;
            case 'CONVERSATION_COMPLETED':
                todayOps = { $inc: { completedConversations: 1 } };
                allTimeOps = { $inc: { completedConversations: 1 } };
                break;
            case 'NEW_LEAD': // Only handle service count here now
                console.log('[AnalyticsService] Handling NEW_LEAD service count.');
                if (data.service) {
                    const serviceKey = `leadsByService.${data.service.replace(/[.$]/g, "_")}`;
                    console.log(`[AnalyticsService] Incrementing service key: ${serviceKey}`);
                    // Use $set to ensure the nested object structure if needed, or just $inc
                    todayOps = { $inc: { [serviceKey]: 1 } }; 
                    allTimeOps = { $inc: { [serviceKey]: 1 } }; 
                } else {
                    console.log('[AnalyticsService] No service data provided for NEW_LEAD service count.');
                }
                // DO NOT break here if other logic needs to run after switch
                break;
            case 'LEAD_STATUS_UPDATE':
                if (data.oldStatus && data.newStatus && data.oldStatus !== data.newStatus) {
                    todayOps = {
                        $inc: {
                            [`leadStatus.${data.oldStatus}`]: -1,
                            [`leadStatus.${data.newStatus}`]: 1
                        }
                    };
                    allTimeOps = {
                        $inc: {
                            [`leadStatus.${data.oldStatus}`]: -1,
                            [`leadStatus.${data.newStatus}`]: 1
                        }
                    };
                }
                break;
            case 'HOURLY_ACTIVITY':
                const hour = new Date().getHours().toString();
                todayOps = { $inc: { [`hourlyActivity.${hour}`]: 1 } };
                allTimeOps = { $inc: { [`hourlyActivity.${hour}`]: 1 } };
                break;
            default:
                 console.log(`[AnalyticsService] Unknown or already handled event type: ${eventType}`);
                 break;
        } // End switch

        console.log('[AnalyticsService] Ops generated by switch (Today - Others):', JSON.stringify(todayOps));
        console.log('[AnalyticsService] Ops generated by switch (All Time - Others):', JSON.stringify(allTimeOps));

        // Execute remaining updates if any operations were defined
        if (Object.keys(todayOps).length > 0 || Object.keys(allTimeOps).length > 0) {
            console.log('[AnalyticsService] Executing remaining DB updates (conversations, services, etc.)...');
            // Use Promise.allSettled if you want to ensure one update failure doesn't stop others
            await Promise.all([
                Object.keys(todayOps).length > 0 ? 
                    ChatAnalytics.updateOne({ businessId, date: today }, todayOps, { upsert: true }) : 
                    Promise.resolve(), // Resolve immediately if no ops
                
                Object.keys(allTimeOps).length > 0 ?
                    ChatAnalytics.updateOne({ businessId, date: null }, allTimeOps, { upsert: true }) :
                    Promise.resolve() // Resolve immediately if no ops
            ]);
            console.log('[AnalyticsService] Remaining MongoDB updates promise resolved.');
        } else {
            console.log('[AnalyticsService] No remaining update operations defined. Skipping DB update.');
        }

        // --- Fetch final data and Calculate Conversion Rate --- 
        // Fetch the potentially updated records *after* all updates
        const [finalToday, finalAllTime] = await Promise.all([
             ChatAnalytics.findOne({ businessId, date: today }),
             ChatAnalytics.findOne({ businessId, date: null })
        ]);
        
        if (finalAllTime && finalAllTime.totalConversations > 0) {
            console.log('[AnalyticsService] Calculating and updating conversion rate...');
            const conversionRate = Math.min((finalAllTime.totalLeads / finalAllTime.totalConversations) * 100, 100);
            // Perform final update for conversion rate
            await Promise.all([
                 ChatAnalytics.updateOne({ businessId, date: today }, { $set: { conversionRate } }),
                 ChatAnalytics.updateOne({ businessId, date: null }, { $set: { conversionRate } })
            ]);
             console.log('[AnalyticsService] Conversion rate update complete.');
        } else {
            console.log('[AnalyticsService] Skipping conversion rate update (no conversations or data).');
        }
        // --- End Conversion Rate --- 

        return { today: finalToday, allTime: finalAllTime }; // Return the latest fetched data

    } catch (error) {
        console.error('[AnalyticsService] Error tracking chat event:', error);
        throw error;
    }
};

/**
 * Gets analytics for a specific date range
 */
export const getAnalytics = async (businessId, startDate, endDate) => {
    try {
        const [rangeAnalytics, allTimeAnalytics] = await Promise.all([
            ChatAnalytics.find({
                businessId,
                date: {
                    $gte: new Date(startDate),
                    $lte: new Date(endDate)
                }
            }).sort({ date: 1 }),
            ChatAnalytics.findOne({
                businessId,
                date: null
            })
        ]);

        return {
            dailyData: rangeAnalytics,
            allTime: allTimeAnalytics
        };
    } catch (error) {
        console.error('Error fetching analytics:', error);
        throw error;
    }
};

/**
 * Gets today's analytics summary
 */
export const getTodaysSummary = async (businessId) => {
    try {
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        const [todayAnalytics, allTimeAnalytics] = await Promise.all([
            ChatAnalytics.findOne({
                businessId,
                date: today
            }),
            ChatAnalytics.findOne({
                businessId,
                date: null
            })
        ]);

        const defaultAnalytics = {
            businessId,
            totalLeads: 0,
            leadsByService: {},
            leadStatus: { new: 0, contacted: 0, converted: 0 },
            totalConversations: 0,
            completedConversations: 0,
            hourlyActivity: {},
            conversionRate: 0
        };

        // Ensure we have valid data objects
        const todayData = todayAnalytics || { ...defaultAnalytics, date: today };
        const allTimeData = allTimeAnalytics || { ...defaultAnalytics, date: null };

        // Calculate all-time conversion rate
        const allTimeConversionRate = allTimeData.totalConversations > 0 
            ? (allTimeData.totalLeads / allTimeData.totalConversations) * 100
            : 0;

        // Format response to match frontend expectations
        return {
            success: true,
            data: {
                today: {
                    totalLeads: todayData.totalLeads,
                    leadsByService: todayData.leadsByService,
                    leadStatus: todayData.leadStatus,
                    totalConversations: todayData.totalConversations,
                    completedConversations: todayData.completedConversations,
                    hourlyActivity: todayData.hourlyActivity,
                    conversionRate: todayData.conversionRate,
                    date: today
                },
                allTime: {
                    totalLeads: allTimeData.totalLeads,
                    totalConversations: allTimeData.totalConversations,
                    conversionRate: allTimeConversionRate
                }
            }
        };
    } catch (error) {
        console.error('Error fetching today\'s analytics:', error);
        throw error;
    }
}; 